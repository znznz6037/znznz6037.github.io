---
layout: post
title: "알고리즘 문제에서 mod 1000000007 연산을 하는 이유와 관련 문제 풀이"
date: "2021-10-03 19:34:10"
categories: [알고리즘]
tags: [알고리즘, Softeer] 

---

많은 수학 관련 알고리즘 문제들에서 계산하는 값이 커질 경우 1000000007(이하 1e9+7) 로 mod 연산 결과값을 요구하는 문제들이 많다.  왜 그럴까?  

int의 경우 4byte(32bit)이므로 최대값이 2^31- 1로,  2e9 정도의 근사값을 가진다.

`int로 나타낼 수 있는 값을 최대한 활용하기 위해 int의 최대값에 가장 가까운 소수인 2^30에 근사한 1e9+7을 사용하는 것이다.`  

2^31 근사값인 2e9+11을 사용하지 않는 이유는, 2e9 값으로 덧셈을 하게 된다면 2e9 + 2e9 = 4e9로 int 범위를 초과하여 오버플로우가 발생하게 되기 때문이다.   
또한 1e9 값으로 곱셈 연산을 해도 1e9 * 1e9 = 1e18 로, long 범위를 초과하지 않는 장점도 있다.[^1]



[관련 문제](https://softeer.ai/practice/info.do?eventIdx=1&psProblemId=407&sw_prbl_sbms_sn=18444)

### 제한시간 : C/C++(1초), Java/Python(2초) | 메모리 제한 : 256MB

> 바이러스가 숙주의 몸속에서 1초당 P배씩 증가한다.  
> 처음에 바이러스 K마리가 있었다면 N초 후에는 총 몇 마리의 바이러스로 불어날까? N초 동안 죽는 바이러스는 없다고 가정한다.

### 입력형식

> 첫 번째 줄에 처음 바이러스의 수 K, 증가율 P, 총 시간 N(초)이 주어진다.  
> 입력은 다음 조건을 만족한다. 
>
> - $1 <= K <= 10^8$ 인 정수 
> - $1 <= P <= 10^8$ 인 정수 
> - $1 <= N <= 10^6$ 인 정수 

### 출력형식

> 최종 바이러스 개수를 1000000007로 나눈 나머지를 출력하라.

### 입력예제

> 2 3 2

### 출력예제

> 18

<br/>

### 풀이

```java
import java.util.Scanner;

public class virus {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int K = sc.nextInt();
        int P = sc.nextInt();
        int N = sc.nextInt();

        sc.close();
      
        long virus = K;
        int remainder = 1000000007;

      	// K <= 10 ^ 8, P <= 10 ^ 8, N <= 10 ^ 6
        // virus 수는 최대 10 ^ (8 + 8 * 6) = 10 ^ 56
        for(int i = 0; i < N; i++) {
            virus *= P;
            if(virus > mod) virus %= mod;
        }

        System.out.print(virus);
    }
}
```
K * P ^ N % 1000000007 연산을 하면 간단하게 나올 것 같지만,  
입력 형식을 보면 K <= 10 ^ 8, P <= 10 ^ 8, N <= 10 ^ 6로,  바이러스 수는 최대 10^56을 가질 수 있으므로  long 타입을 쓴다고 하더라도 오버플로우가 발생하게 된다.  
대신에 범위제한이 없는 Biginteger 로 선언하여 pow 함수를 써서 제출해봤지만 제한시간인 2초를 초과하게 되었다.

결론은, 증가율을 계속 곱하면서 1e9+7값을 초과할 경우 1e9+7값으로 계속 나머지 연산을 수행함으로써 오버플로우를 방지하면 적절한 값을 얻을 수 있다. 

`이게 가능한 이유는, 나머지 연산의 경우 일반적으로 우리가 알고 있는 분배법칙이 적용되지 않기 때문이다.`[^2]

```null
(A + B) % p = ((A % p) + (B % p)) % p
(A * B) % p = ((A % p) * (B % p)) % p
(A - B) % p = ((A % p) - (B % p) + p) % p
(A / B) % p -> 나눗셈에 대한 나머지 연산은 따로 페르마의 소정리 공식 이용
```

또한 바이러수 수를 담을 변수는 long 타입으로 선언해야하는데, 초기 바이러스 수는 최대 10^8, 증가율 최대 10^8 이므로, 곱하면 10^16으로 int 범위를 초과하여 오버플로우가 발생하기 때문이다.



#### 참고 문헌

[^1]: [[PS기초] 왜 1000000007(1e9+7)로 나눈 나머지를 고집할까? (feat. 모듈러 곱셈 역원)](https://www.facebook.com/algoguide/posts/1117664551755294/)
[^2]: [나머지 연산 분배법칙](https://velog.io/@gidskql6671/나머지Modulo-연산-분배법칙)